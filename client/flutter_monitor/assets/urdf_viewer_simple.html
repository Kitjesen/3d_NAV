<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Robot Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }
        #container {
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Load Three.js as global script (NOT ES6 module) -->
    <script src="./libs/three.min.js"></script>
    
    <script>
        console.log('üåê Script starting...');
        console.log('‚úÖ THREE loaded:', typeof THREE !== 'undefined');
        
        // Global variables
        let scene, camera, renderer;
        let robotGroup;
        let isReady = false;
        let needsRender = true;
        
        // Manual camera controls (replacing OrbitControls)
        let cameraDistance = 3;
        let cameraAngleX = Math.PI / 6;  // Elevation angle
        let cameraAngleY = Math.PI / 4;  // Azimuth angle
        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastTouchDistance = 0;

        // Initialize the 3D scene
        function init() {
            console.log('üöÄ Initializing Three.js scene...');
            const container = document.getElementById('container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Dark background
            scene.fog = new THREE.Fog(0x1a1a1a, 8, 40);
            console.log('‚úÖ Scene created');

            // Camera
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(2, 1.5, 2);
            camera.lookAt(0, 0.3, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            console.log('‚úÖ Renderer created');

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
            hemiLight.position.set(0, 1, 0);
            scene.add(hemiLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -5;
            directionalLight.shadow.camera.right = 5;
            directionalLight.shadow.camera.top = 5;
            directionalLight.shadow.camera.bottom = -5;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3); // Blue fill light
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);
            console.log('‚úÖ Lights added');

            // Ground Grid
            createGround();

            // Robot Group
            robotGroup = new THREE.Group();
            scene.add(robotGroup);

            // Use simple robot model for best performance
            createSimpleRobot();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Setup touch/mouse controls
            setupControls();

            // Start animation loop
            animate();
            console.log('‚úÖ Animation started');

            // Notify Flutter that scene is ready
            isReady = true;
            needsRender = true; // Request initial render
            console.log('‚úÖ Scene initialization complete');
            sendMessageToFlutter({
                type: 'ready',
                message: 'Three.js scene initialized (simple mode)'
            });
        }

        function createGround() {
            // Grid Helper
            const gridHelper = new THREE.GridHelper(20, 40, 0x444444, 0x333333); // Darker grid lines
            gridHelper.position.y = 0;
            scene.add(gridHelper);

            // Ground Plane (for shadows)
            const groundGeometry = new THREE.PlaneGeometry(40, 40);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a, // Match background
                metalness: 0.0,
                roughness: 1.0
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = -0.01; // Slightly below grid
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Axes Helper
            const axesHelper = new THREE.AxesHelper(0.5);
            axesHelper.position.y = 0.01;
            scene.add(axesHelper);
            
            console.log('‚úÖ Ground created');
        }

        // STL Binary Loader (without ES6 modules)
        function loadSTLBinary(url, callback) {
            console.log('üî® Loading STL:', url);
            
            fetch(url)
                .then(res => {
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return res.arrayBuffer();
                })
                .then(buffer => {
                    console.log('üì¶ STL data received:', buffer.byteLength, 'bytes');
                    const geometry = parseSTLBinary(buffer);
                    callback(geometry);
                })
                .catch(err => {
                    console.error('‚ùå STL load failed:', url, err);
                    callback(null);
                });
        }

        function parseSTLBinary(buffer) {
            const view = new DataView(buffer);
            const triangleCount = view.getUint32(80, true);
            
            console.log('üìê Parsing STL with', triangleCount, 'triangles');
            
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            
            let offset = 84;
            for (let i = 0; i < triangleCount; i++) {
                // Normal
                const nx = view.getFloat32(offset, true); offset += 4;
                const ny = view.getFloat32(offset, true); offset += 4;
                const nz = view.getFloat32(offset, true); offset += 4;
                
                // 3 vertices
                for (let j = 0; j < 3; j++) {
                    vertices.push(view.getFloat32(offset, true)); offset += 4;
                    vertices.push(view.getFloat32(offset, true)); offset += 4;
                    vertices.push(view.getFloat32(offset, true)); offset += 4;
                    normals.push(nx, ny, nz);
                }
                
                offset += 2; // Skip attribute bytes
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.computeBoundingBox();
            
            console.log('‚úÖ STL parsed successfully');
            return geometry;
        }

        function loadRealRobotMeshes() {
            console.log('ü§ñ Loading real robot meshes...');
            robotGroup.clear();

            const meshFiles = [
                'base_link.STL',
                'fl_hip_Link.STL',
                'fl_thigh_Link.STL',
                'fl_calf_Link.STL',
                'fr_hip_Link.STL',
                'fr_thigh_Link.STL',
                'fr_calf_Link.STL',
                'rl_hip_Link.STL',
                'rl_thigh_Link.STL',
                'rl_calf_Link.STL',
                'rr_hip_Link.STL',
                'rr_thigh_Link.STL',
                'rr_calf_Link.STL'
            ];

            let loadedCount = 0;
            const targetCount = meshFiles.length;

            const material = new THREE.MeshStandardMaterial({
                color: 0x8f9db0,
                metalness: 0.3,
                roughness: 0.6
            });

            meshFiles.forEach(filename => {
                const url = `./meshes/${filename}`;
                loadSTLBinary(url, (geometry) => {
                    loadedCount++;
                    
                    if (geometry) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        // Scale from mm to m (assuming STL is in mm)
                        mesh.scale.set(0.001, 0.001, 0.001);
                        robotGroup.add(mesh);
                        console.log(`‚úÖ Loaded ${filename} (${loadedCount}/${targetCount})`);
                    } else {
                        console.warn(`‚ö†Ô∏è Failed ${filename} (${loadedCount}/${targetCount})`);
                    }

                    if (loadedCount === targetCount) {
                        console.log('üéâ All meshes loaded!');
                        // Center the model
                        const box = new THREE.Box3().setFromObject(robotGroup);
                        const center = box.getCenter(new THREE.Vector3());
                        robotGroup.position.sub(center);
                        robotGroup.position.y = 0.3; // Lift above ground
                    }
                });
            });
        }

        function createSimpleRobot() {
            console.log('ü§ñ Creating simple robot model...');
            robotGroup.clear();

            // Body (box)
            const bodyGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x007AFF,
                metalness: 0.3,
                roughness: 0.6
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.3, 0);
            body.castShadow = true;
            body.receiveShadow = true;
            robotGroup.add(body);

            // Head indicator (smaller box)
            const headGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.15);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF3B30,
                metalness: 0.4,
                roughness: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.25, 0.35, 0);
            head.castShadow = true;
            robotGroup.add(head);

            // Legs (4 cylinders)
            const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.25, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.5,
                roughness: 0.5
            });

            const legPositions = [
                [0.15, 0.125, 0.2],
                [0.15, 0.125, -0.2],
                [-0.15, 0.125, 0.2],
                [-0.15, 0.125, -0.2]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.castShadow = true;
                robotGroup.add(leg);
            });

            // Direction arrow
            const arrowHelper = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 0.45, 0),
                0.3,
                0xFFCC00,
                0.1,
                0.05
            );
            robotGroup.add(arrowHelper);

            console.log('‚úÖ Simple robot model created');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupControls() {
            const canvas = renderer.domElement;
            
            // Mouse/Touch start
            function onStart(clientX, clientY) {
                isDragging = true;
                lastTouchX = clientX;
                lastTouchY = clientY;
            }
            
            // Mouse/Touch move
            function onMove(clientX, clientY) {
                if (!isDragging) return;
                
                const deltaX = clientX - lastTouchX;
                const deltaY = clientY - lastTouchY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngleX - deltaY * 0.01));
                
                lastTouchX = clientX;
                lastTouchY = clientY;
                
                updateCameraPosition();
            }
            
            // Mouse/Touch end
            function onEnd() {
                isDragging = false;
            }
            
            // Mouse events
            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                onStart(e.clientX, e.clientY);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    onMove(e.clientX, e.clientY);
                }
            });
            
            canvas.addEventListener('mouseup', onEnd);
            canvas.addEventListener('mouseleave', onEnd);
            
            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    onStart(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    // Pinch to zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    onMove(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    // Pinch to zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = distance - lastTouchDistance;
                    
                    cameraDistance = Math.max(0.5, Math.min(10, cameraDistance - delta * 0.01));
                    lastTouchDistance = distance;
                    
                    updateCameraPosition();
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (e.touches.length === 0) {
                    onEnd();
                }
            });
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance = Math.max(0.5, Math.min(10, cameraDistance + e.deltaY * 0.001));
                updateCameraPosition();
            }, { passive: false });
            
            console.log('‚úÖ Touch/Mouse controls enabled');
        }

        function updateCameraPosition() {
            const x = cameraDistance * Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
            const y = cameraDistance * Math.cos(cameraAngleX);
            const z = cameraDistance * Math.sin(cameraAngleX) * Math.sin(cameraAngleY);
            
            camera.position.set(x, y, z);
            camera.lookAt(0, 0.3, 0);
            needsRender = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Only render when needed (on-demand rendering for better performance)
            if (needsRender) {
                renderer.render(scene, camera);
                needsRender = false;
            }
        }
        
        function requestRender() {
            needsRender = true;
        }

        // Update robot pose from Flutter
        function updateRobotPose(x, y, z, qx, qy, qz, qw) {
            if (!robotGroup) return;

            robotGroup.position.set(x, y, z);
            
            const quaternion = new THREE.Quaternion(qx, qy, qz, qw);
            robotGroup.setRotationFromQuaternion(quaternion);
            
            needsRender = true;
        }

        // Send message to Flutter
        function sendMessageToFlutter(message) {
            if (window.FlutterChannel) {
                window.FlutterChannel.postMessage(JSON.stringify(message));
            }
        }

        // Expose functions to Flutter
        window.updateRobotPose = updateRobotPose;
        window.loadRealMeshes = loadRealRobotMeshes;
        window.loadSimpleModel = createSimpleRobot;
        console.log('‚úÖ Functions exposed to window');

        // Initialize on load
        console.log('üìÑ Waiting for page load...');
        if (document.readyState === 'complete') {
            console.log('‚ö° Document already loaded, initializing immediately');
            init();
        } else {
            window.addEventListener('load', () => {
                console.log('üìÑ Page load event fired');
                init();
            });
        }
    </script>
</body>
</html>
